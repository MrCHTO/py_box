# 第一章 汇编语言基础知识
## 1 - 计算机系统概述
### 1.1 - 硬件（Hardware）
* 中央处理单元CPU。
* 控制器、运算器、寄存器。
* 存储器。
* 主存储器：RAM和ROM。
* 辅助存储器：磁盘、光盘、U盘。
* 外部设备。
* 输入设备和输出设备。
#### 1.1.1 - 重要硬件
* 中央处理单元 CPU（Intel 80x86）->**其中的寄存器**
* 存储器（主存储器）->**存储器地址**
* 外部设备（接口电路）->**端口（I/O地址）**
### 1.2 - 软件（Software）
* 系统软件
* 应用软件
### 1.3 - 微型计算机的系统组成

![image-20200915145545401](%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86.assets/image-20200915145545401.png)

### 1.4 - 寄存器
* 寄存器是CPU内部的高速存储单元。
* 为处理器提供各种操作所需要的数据或地址等信息。
* 汇编语言程序采用它们各自的符号名。
#### 1.4.1 - 16位Intel 8086/80286 CPU
* AX BX CX DX SI DI BP SP
#### 1.4.2 - 32位80386/80486/Pentium CPU
* EAX EBX ECX EDX ESI EDI EBP ESP
### 1.5 - 存储器地址
* 存储器是由大量存储单元组成，需要用编号区别每个单元。
* 编号 ＝ 地址。
* 存储器地址是存储器中存储单元的编号。
* 每个存储单元存放一个字节量的数据
* 一个字节B（Byte）＝8个二进制位b（bit）
* 采用十六进制数来表达地址
* Intel 8086具有1兆字节（1MB）存储器容量
* 存储器地址表示为：00000H ～ FFFFFH
* 其中大写H（或小写h）表示是十六进制数
### 1.6 - 端口
* I/O接口电路由接口寄存器组成，需要用编号区别各个寄存器。
* 编号＝地址
* I/O地址是接口电路中寄存器的编号
* 端口是I/O地址的通俗说法
* 系统通过这些端口与外设进行通信
* 采用十六进制数来表达端口
* Intel 8086支持64K个8位端口
* I/O地址可以表示为：0000H ～ FFFFH
## 2 - 8086微处理器

![image-20200915151632236](%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86.assets/image-20200915151632236.png)

### 2.1 - 微处理器
* 主要包含指令执行的运算和控制部件，还有多种寄存器。
* 抽象为以名称存取的寄存器。
* AX寄存器（16位）可拆分为独立的两个8位寄存器（AH&&AL）BCD同理。
### 2.2 - 内部结构（寄存器一般是16位）
#### 2.2.1 - 总线接口单元（BIU）
* 负责读取指令和操作数。
##### 段寄存器

> 8086有4个16位段寄存器，每个段寄存器确定一个逻辑段的起始地址，每种逻辑段均有各自的用途。
> 8086对逻辑段要求：段地址低4位均为0，每段最大不超过64KB。
>
> ![image-20201022161351307](%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86.assets/image-20201022161351307.png)
>
> 8086对逻辑段并不要求：必须是64KB，各段之间完全分开（即可以重叠）。
>
> ![image-20201022161409809](C:%5CUsers%5CMr_CH%5COneDrive%5C%E6%96%87%E6%A1%A3%5CMD_BOX%5CCLASS%5C%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86.assets%5Cimage-20201022161409809.png)


* CS（代码段）：指明代码段的起始地址。
    * 代码段用来存放程序的指令序列。
    * 代码段寄存器CS存放代码段的段地址。
    * 指令指针寄存器IP指示下条指令的偏移地址。
    * 处理器利用CS:IP取得下一条要执行的指令。    


* DS（数据段）：指明堆栈段的起始地址。
    * 堆栈段确定堆栈所在的主存区域。
    * 堆栈段寄存器SS存放堆栈段的段地址。
    * 堆栈指针寄存器SP指示堆栈栈顶的偏移地址。
    * 处理器利用SS:SP操作堆栈顶的数据。


* SS（堆栈段）：指明数据段的起始地址。
    * 数据段存放运行程序所用的数据
    * 数据段寄存器DS存放数据段的段地址。
    * 各种主存寻址方式（有效地址EA）得到存储器中操作数的偏移地址。
    * 处理器利用DS:EA存取数据段中的数据。


* ES（附加段）：指明附加段的起始地址。
    * 附加段是附加的数据段，也用于数据的保存。
    * 附加段寄存器ES存放附加段的段地址。
    * 各种主存寻址方式（有效地址EA）得到存储器中操作数的偏移地址。
    * 处理器利用ES:EA存取附加段中的数据。
    * 串操作指令将附加段作为其目的操作数的存放区域。


>程序的指令序列必须安排在代码段。
>程序使用的堆栈一定在堆栈段。
>程序中的数据默认是安排在数据段，也经常安排在附加段，尤其是串操作的目的区必须是附加段。
>数据的存放比较灵活，实际上可以存放在任何一种逻辑段中。

* 使用规定
|访问方式|默认|可超越|偏移地址|
|:-:|:-:|:-:|:-:|
|取指令|CS|无|IP|
|堆栈操作|SS|无|SP|
|一般数据访问|DS|CS ES SS|有效地址EA|
|BP基址的寻址方式|SS|CS ES DS|有效地址EA|
|串操作的源操作数|DS|CS ES SS|SI|
|串操作的目的操作数|ES|无|DI|

##### 段超越前缀指令
>没有指明时，一般的数据访问在DS段；使用BP访问主存，则在SS段。

* 默认的情况允许改变，需要使用段超越前缀指令；8086指令系统中有4个。
    * CS：代码段超越，使用代码段的数据。
    * SS：堆栈段超越，使用堆栈段的数据。
    * DS：数据段超越，使用数据段的数据。
    * ES：附加段超越，使用附加段的数据。

* 示例：
>没有段超越的指令实例：
>MOV AX,[2000H]
>AX←DS:[2000H]
>从默认的DS数据段取出数据

>采用段超越前缀的指令实例：
>MOV AX,ES:[2000H]
>AX←ES:[2000H]
>从指定的ES附加段取出数据


##### 指令指针寄存器（IP）
* 是一个专用寄存器，指示代码段中指令的偏移地址。
* 它与代码段寄存器CS联用，确定下一条指令的物理地址。
* 计算机通过CS : IP寄存器来控制指令序列的执行流程。
#### 2.2.2 - 执行单元（EU）
* 负责指令译码和执行。
##### 通用寄存器
* 数据寄存器：器用来存放计算的结果和操作数，也可以存放地址。
    * AX（累加器）：用于算术、逻辑运算以及与外设传送信息等。
    * BX（基址寄存器）：做存放存储器地址。
    * CX（计数器）：作为循环和串操作等指令中的隐含计数器。
    * DX（数据寄存器）：用来存放双字长数据的高16位，存放外设端口地址。


* 指针寄存器：指针寄存器用于寻址内存堆栈内的数据。 
    * SP（堆栈指针）：指示栈顶的偏移地址，不能再用于其他目的，具有专用目的。
    * BP（基址指针）：表示数据在堆栈段中的基地址。


* 变址寄存器：常用于存储器寻址时提供地址。
    * SI（源地址寄存器）。
    * DI（目的地址寄存器）。
    
>SI和DI在串操作指令有特殊用法。
>SP和BP寄存器与SS段寄存器联合使用确定堆栈段中的存储单元地址。

##### 标志寄存器（FLAGS）
* 反映指令执行结果或控制指令执行形式。


* 状态标志：用来记录程序运行结果的状态信息。
    * CF（进位标志）：运算结果的最高有效位有进位（加法）或借位（减法），即CF = 1；否则CF = 0。
    * ZF（零标志）：运算结果为0，则ZF = 1，否则ZF = 0。
    * SF（符号标志）：运算结果最高位为1，则SF = 1；否则SF = 0。
        *  有符号数据用最高有效位表示数据的符号，最高有效位就是符号标志的状态。
    * PF （奇偶标志）：运算结果最低字节中“1”的个数为零或偶数时，PF = 1；否则PF = 0。
        * PF标志仅反映最低8位中“1”的个数是偶或奇，即使是进行16位字操作。
    * OF（溢出标志）：算术结果有溢出，OF = 1，否则 OF = 0。
    * AF（辅助进位标志）：运算时D~3~位（低半字节）有进位或者错位时，AF = 1，否则 AF = 1。
        *   这个标志主要由处理器内部使用，用于十进制算术运算调整指令中。


* 控制标志：由程序根据需要用指令设置，用于控制处理器执行指令的方式。
    * DF（方向标志）：用于串操作指令，控制地址的变化方向。
        * CLD（指令复位方向标志）：DF = 0，存储器地址自动增加。
        * STD（指令置位方向标志）：DF = 1，存储器地址自动减少。
    * IF（硬件中断允许标志位）：用于控制外部可屏蔽中断是否可以被处理器响应。
        * CLI（指令复位中断标志）：IF＝1，则允许中断。
        * STI（指令置位中断标志）：IF＝0，则禁止中断。
    * TF（陷阱标志&&单步标志）：用于控制处理器进入单步操作方式。
        * TF＝0，处理器正常工作。
        * TF＝1，处理器单步执行指令。


>单步执行指令——处理器在每条指令执行结束时，便产生一个编号为1的内部中断。
>这种内部中断称为单步中断。
>所以TF也称为单步标志。
>利用单步中断可对程序进行逐条指令的调试。
>这种逐条指令调试程序的方法就是单步调试。

### 2.3 - 地址关系
#### 2.3.1 - 逻辑地址
* 分段后用户编程时，采用逻辑地址。
* 逻辑地址（CS:IP） = 段（基）地址：（段内）偏移地址。
##### 段地址
* 说明逻辑段在主存中的起始位置。
* 8086规定段地址必须是模16地址：xxxx0H。
* 省略低4位0000B，段地址就可以用16位数据表示，就能用16位段寄存器表达段地址。
##### 偏移地址
* 偏移地址说明主存单元距离段起始位置的偏移量。
* 每段不超过64KB，偏移地址也可用16位数据表示。
#### 2.3.2 - 物理地址
* 每个物理存储单元有一个唯一的编号，即物理地址：00000H～FFFFFH。
* 一个物理地址可以有多个逻辑地址。
* 物理地址（20位） = 逻辑地址（16位） \* 10H（左移四位）

![image-20200916201703477](C:%5CUsers%5CMr_CH%5COneDrive%5C%E6%96%87%E6%A1%A3%5CMD_BOX%5CCLASS%5C%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86.assets%5Cimage-20200916201703477.png)

### 2.4 - 堆栈
* 堆栈是主存中一个特殊的区域。
* 它采用先进后出FILO（First In Last Out）或后进先出LIFO（Last In First Out）的原则进行存取操作，而不是随机存取操作方式。
* 堆栈通常由处理器自动维持。
* 在8086中，由堆栈段寄存器SS和堆栈指针寄存器SP共同指示。
### 2.5 - 溢出和进位
* 溢出标志OF和进位标志CF是两个意义不同的标志。
* 进位标志表示无符号数运算结果是否超出范围，超出范围后加上进位或借位运算结果仍然正确。
* 溢出标志表示有符号数运算结果是否超出范围，超出范围后运算结果不正确

>处理器对两个操作数进行运算时，按照无符号数求得结果，并相应设置进位标志CF；同时，根据是否超出有符号数的范围设置溢出标志OF。

>应该利用哪个标志，则由程序员来决定。也就是说，如果将参加运算的操作数认为是无符号数，就应该关心进位；认为是有符号数，则要注意是否溢出。

#### 2.5.1 - 溢出的判断
##### 判断简单规则
* 只有当两个相同符号数相加（包括不同符号数相减），而运算结果的符号与原数据符号相反时，产生溢出。因为，此时的运算结果显然不正确。其他情况下，则不会产生溢出。
## 3 - 数据信息的表达单位
### 3.1 - 计算机中信息的单位
* 二进制位Bit：存储一位二进制数：0或1
* 字节Byte：8个二进制位，D~7~～D~0~。
* 字Word：16位，2个字节，D~15~～D~0~。
* 双字Word：32位，4个字节，D~31~～D~0~。
* 最低有效位LSB：数据的最低位，D~0~位。
* 最高有效位MSB：数据的最高位，对应字节、字、双字分别指D~7~、D~15~、D~31~位。

![image-20200915154902613](C:%5CUsers%5CMr_CH%5COneDrive%5C%E6%96%87%E6%A1%A3%5CMD_BOX%5CCLASS%5C%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86.assets%5Cimage-20200915154902613.png)

#### 3.1.1 - 1MB空间的分段
* 1MB空间最多能分成多少个段？
    * 每隔16个存储单元就可以开始一个段
    * 所以1MB最多可以有：
    * 2^20^÷16＝2^16^＝64K 个段
* 1MB空间最少能分成多少个段？
    * 每隔64K个存储单元开始一个段
    * 所以1MB最少可以有：
    * 2^20^÷2^16^＝16 个段

### 3.2 - 存储单元及其存储内容
* 主存储器需要利用地址区别。
* 每个存储单元都有一个编号，被称为存储器地址。
* 每个存储单元存放一个字节的内容。

>0002H单元存放有一个数据34H，表达为[0002H]＝34H

### 3.3 - 多字节数据存放方式
* 多字节数据在存储器中占连续的多个存储单元。
* 存放：低字节存入低地址，高字节存入高地址。
* 表达：用低地址表示多字节数据占据的地址空间。

>2号“字”单元的内容为：[0002H] = 1234H
>2号“双字”单元的内容为：[0002H] = 78561234H

### 3.4 - 数据的地址对齐
* 同一个存储器地址可以是字节单元地址、字单元地址、双字单元地址等等。
* 字单元安排在偶地址（xxx0B）、双字单元安排在模4地址（xx00B）等，被称为“地址对齐”。
* 对于不对齐地址的数据，处理器访问时，需要额外的访问存储器时间。
* 应该将数据的地址对齐，以取得较高的存取速度。
### 3.5 - 存储器的分段管理
#### 8086 CPU
* 有20条地址线。
* 最大可寻址空间为220＝1MB。
* 物理地址范围从00000H～FFFFFH。
* 将1MB空间分成许多逻辑段。
* 每个段最大限制为64KB。
* 段地址的低4位为0000B。
* 一个存储单元除具有一个唯一的物理地址外，还具有多个逻辑地址。
### 4 - 指令
#### 4.1 - 指令的组成

![image-20201022162101274](C:%5CUsers%5CMr_CH%5COneDrive%5C%E6%96%87%E6%A1%A3%5CMD_BOX%5CCLASS%5C%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86.assets%5Cimage-20201022162101274.png)

* 指令由操作码和操作数两部分组成。
* 操作码说明计算机要执行哪种操作，如传送、运算、移位、跳转等操作，它是指令中不可缺少的组成部分。
* 操作数是指令执行的参与者，即各种操作的对象。
* 有些指令不需要操作数，通常的指令都有一个或两个操作数，个别指令有3个甚至4个操作数。

#### 4.2 - 指令的操作码
* 用一个唯一的助记符表示（指令功能的英文缩写）
* 对应着机器指令的一个二进制编码

#### 4.3 - 指令的操作数
* 可以是一个具体的数值
* 可以是存放数据的寄存器
* 指明数据在主存位置的存储器地址

#### 4.4 - 代码示例
##### 4.4.1 - 8086机器

![image-20201022162724840](C:%5CUsers%5CMr_CH%5COneDrive%5C%E6%96%87%E6%A1%A3%5CMD_BOX%5CCLASS%5C%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86.assets%5Cimage-20201022162724840.png)

##### 4.4.2 - 标准机器

![image-20201022162742913](C:%5CUsers%5CMr_CH%5COneDrive%5C%E6%96%87%E6%A1%A3%5CMD_BOX%5CCLASS%5C%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86.assets%5Cimage-20201022162742913.png)

##### 4.4.3 - 其他机器

![image-20201022162810060](C:%5CUsers%5CMr_CH%5COneDrive%5C%E6%96%87%E6%A1%A3%5CMD_BOX%5CCLASS%5C%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86.assets%5Cimage-20201022162810060.png)

#### 4.5 - 指令的助记符格式
>操作码  操作数1,操作数2	；注释
>操作数2，称为源操作数 src，它表示参与指令操作的一个对象
>操作数1，称为目的操作数 dest，它不仅可以作为指令操作的一个对象，还可以用来存放指令操作的结果
>分号后的内容是对指令的解释

#### 4.5.1 - 寻址方式的多种表示方式

![image-20201022164042328](C:%5CUsers%5CMr_CH%5COneDrive%5C%E6%96%87%E6%A1%A3%5CMD_BOX%5CCLASS%5C%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86.assets%5Cimage-20201022164042328.png)

#### 4.5.2 - 寄存器操作数的表达
* r8：任意一个8位通用寄存器（AH  AL   BH  BL   CH  CL   DH  DL）。
* r16：任意一个16位通用寄存器（AX  BX  CX  DX    SI  DI  BP  SP）。
* reg：代表r8或r16。
* seg：段寄存器（CS  DS  ES  SS）。
#### 4.5.3 - 存储器操作数的表达
* m8：一个8位存储器操作数单元（所有主存寻址方式）。
* m16：一个16位存储器操作数单元（所有主存寻址方式）。
* mem：代表m8或m16。
#### 4.5.4 - 立即数的表达
* i8：一个8位立即数。
* i16：一个16位立即数。
* imm：代表i8或i16。
* dest：目的操作数。
* src：源操作数。
#### 4.6 - 传送指令（MOV）（例）
##### 4.6.1 - 格式

![image-20201022164343334](C:%5CUsers%5CMr_CH%5COneDrive%5C%E6%96%87%E6%A1%A3%5CMD_BOX%5CCLASS%5C%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86.assets%5Cimage-20201022164343334.png)

##### 4.6.2 - 功能

![image-20201022164353153](C:%5CUsers%5CMr_CH%5COneDrive%5C%E6%96%87%E6%A1%A3%5CMD_BOX%5CCLASS%5C%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86.assets%5Cimage-20201022164353153.png)

##### 4.6.3 - 立即数寻址方式

![image-20201022164411598](C:%5CUsers%5CMr_CH%5COneDrive%5C%E6%96%87%E6%A1%A3%5CMD_BOX%5CCLASS%5C%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86.assets%5Cimage-20201022164411598.png)

##### 4.6.4 - 立即数寻址指令

![image-20201022164433394](C:%5CUsers%5CMr_CH%5COneDrive%5C%E6%96%87%E6%A1%A3%5CMD_BOX%5CCLASS%5C%E6%B1%87%E7%BC%96%E5%8E%9F%E7%90%86.assets%5Cimage-20201022164433394.png)

##### 4.6.5 - 寄存器寻址方式
##### 4.6.6 - 寄存器寻址指令
##### 4.6.7 - 寄存器间接寻址方式
##### 4.6.8 - 寄存器相对寻址方式
##### 4.6.9 - 存储器寻址方式
##### 4.6.10 - 直接寻址方式
##### 4.6.11 - 直接寻址指令
##### 4.6.12 - 基址变址寻址方式
##### 4.6.13 - 相对基址变址寻址方式

# 第二章 8086的指令系统
# 第三章 汇编语言的程序格式
# 第四章 基本汇编语言程序设计
# 第五章  高级汇编语言程序设计
# 第六章  32位指令及其编程
# 第七章  汇编语言与C/C++的混合编程
